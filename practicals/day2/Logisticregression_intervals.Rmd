---
title: "Logistic regression prediction intervals"
author: "Gerko Vink"
output: 
   html_document:
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: false
---

<style type="text/css">
  
body{ /* Normal  */
  font-size: 12px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1.title {
  font-size: 18px;
  color: DarkBlue;
}
h1 { /* Header 1 */
  font-size: 18px;
}
h2 { /* Header 2 */
  font-size: 18px;
}
h3 { /* Header 3 */
  font-size: 18px;
}
code.r{ /* Code block */
  font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
  font-size: 14px;
}
</style>

---

# Load required packages
```{r}
library(tidyverse)
library(magrittr)
library(purrr)
library(ggplot2)
library(GGally)
library(ciTools)
library(caret)
set.seed(123)
```

---

# Grab the `titanic` data
```{r warning=FALSE}
con <- url("https://www.gerkovink.com/erasmus/Day%202/Part%20D/titanic.csv")
titanic <- read_csv(con)
```

---

# Some data editing
```{r}
titanic %<>% 
  mutate(Pclass = factor(Pclass, labels = c("1st class", "2nd class", "3rd class")), 
         Survived = factor(Survived, labels = c("No", "Yes")), 
         row = 1:887)
```

---

# Draw 10000 bootstrapped sets
```{r}
boot <- replicate(n = 1000, 
                  expr = titanic[sample(nrow(titanic), 
                                        replace = TRUE), ], 
                  simplify = FALSE)
```

---

# Fit logistic model on true data set
```{r}
fit <- titanic %$% 
  glm(Survived ~ Pclass + Sex + Age, family = binomial(link = "logit"))
```

---

## Coefficients
```{r}
fit %>% coef()
```

---

## Parameter CI's
```{r}
fit %>% confint
```

---

## Standard errors
```{r}
fit %>% summary %>% .$coefficients
```

---

# Fit logistic models on all bootstrap sets
```{r}
bootfit <- boot %>% 
  map(~.x %$% 
        glm(Survived ~ Pclass + Sex + Age, 
            family = binomial(link = "logit")))
```

---

## Bootstrapped Coefficients
```{r}
bootcoef <- bootfit %>% 
  map(~.x %>% coef()) %>% 
  do.call("rbind", .) %>% 
  as_tibble()

bootcoef %>% colMeans()
ggpairs(bootcoef) 
```

---

## Bootstrapped CI's
```{r}
bootcoef %>% 
  sapply(., function(x) quantile(x, c(.025, .975))) %>% t()
```

---

## Bootstrapped SE's
```{r}
bootcoef %>% 
  sapply(., sd)
```

---

# Comparisons

---

## Coefficients
```{r}
data.frame(original = fit$coefficients, 
           bootstrap = bootcoef %>% colMeans())
```

---

## Confidence intervals
```{r}
list(original = fit %>% confint(), 
     bootstrap = bootcoef %>% 
       sapply(., function(x) quantile(x, c(.025, .975))) %>% t())
```

---

## Standard Errors
```{r}
data.frame(original = fit %>% summary %>% .$coefficients %>% .[, 2],
           bootstrap = bootcoef %>% 
  sapply(., sd))
```

---

# Individual intervals

---

## Bootstrap individual interval
```{r}
# create matrix with size bootstrap \times cases
pred.matrix <- bootfit %>% 
  map(~.x %>% predict()) %>% 
  do.call("rbind", .) 

se.matrix <- bootfit %>% 
  map(~.x %>% predict(se = TRUE) %>% .$se.fit) %>% 
  do.call("rbind", .) 

rows.matrix <- boot %>% 
  map(~.x %>% .$row)  %>% 
  do.call("rbind", .) 

# row predictions
pred.data <- data.frame(rows = c(rows.matrix),
                        pred = c(pred.matrix),
                        se = c(se.matrix)) %>% 
  as_tibble()

# calculate centroids and quantiles
pred <- pred.data %>% group_by(rows) %>% 
  summarize(est = mean(pred), 
            se2 = sd(pred),
            se.fit = mean(se),
            lwr = est - 1.96 * se.fit, #parametric SE
            upr = est + 1.96 * se.fit, #parametric SE
            lwr2 = est - 1.96 * se2, #parametric SE
            upr2 = est + 1.96 * se2, #parametric SE
            lwr.q = quantile(pred, .025), 
            upr.q = quantile(pred, .975))

# convert to prob
pred %<>% mutate(prob = plogis(est),
                 plwr = plogis(lwr),
                 pupr = plogis(upr),
                 plwr.q = plogis(lwr.q),
                 pupr.q = plogis(upr.q))

# head of predictions calculated
pred
```

---

## Compare predictions
```{r}
plot(x = fit %>% predict, 
     y = pred$est, 
     xlab = "fitted predictions",
     ylab = "bootstrapped predictions")
```

## Compare se's
```{r}
y_se <- fit %>% 
  predict(se = TRUE) %>% 
  as.data.frame()
plot(x = y_se$se.fit, 
     y = pred$se.fit, 
     xlab = "fitted standard errors",
     ylab = "bootstrapped fitted standard errors")
plot(x = y_se$se.fit, 
     y = pred$se2, 
     xlab = "fitted standard errors",
     ylab = "bootstrapped sampled standard errors")
```

The standard error based on the bootstrapped sample (`se2` - taking the sd over the available measurements) does not seem right. I will ignore that one for the remainder of the document. 

---

## Individual interval true model 
```{r}
fit %>% 
  predict(se = TRUE) %>% 
  as.data.frame() %>% 
  mutate(prob = plogis(fit),
         lwr = plogis(fit - 1.96 * se.fit),
         upr = plogis(fit + 1.96 * se.fit)) %>% 
  ggplot(aes(x = fit, y = prob)) + 
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = .2) +
  geom_line(lwd = 1) + ylab("Probability of Survival") + xlab("Logodds of Survival") + ggtitle("Interval based on the true data estimates") + theme_classic()
```

---

## Individual interval bootstrapped se
```{r}
pred %>% 
  ggplot(aes(x = est, y = prob)) + 
  geom_ribbon(aes(ymin = plwr, ymax = pupr), alpha = .2) +
  geom_line(lwd = 1) + ylab("Probability of Survival") + xlab("Logodds of Survival") + ggtitle("Interval based on bootstrapped SE") + theme_classic()
```

---

## Individual interval bootstrapped quantile
```{r}
pred %>% 
  ggplot(aes(x = est, y = prob)) + 
  geom_ribbon(aes(ymin = plwr.q, ymax = pupr.q), alpha = .2) +
  geom_line(lwd = 1) + ylab("Probability of Survival") + xlab("Logodds of Survival") + ggtitle("Interval based on bootstrapped quantiles") + theme_classic()
```

---

# Confusion Matrices

---

## Original data predictions (reference = truth)
```{r}
yhat <- fit %>% 
  predict(type = "response") 

yhat <- ifelse(yhat > .5, "Yes", "No") %>%  # easy threshold for brevity
  as.factor()

confusionMatrix(yhat, titanic$Survived)
```


---

## Bootstrapped predictions (reference = truth)
```{r}
predicted <- ifelse(pred$prob > .5, "Yes", "No") %>% 
  as.factor()

confusionMatrix(predicted, titanic$Survived)
```

---

## Bootstrapped vs original data predictions (reference = bootstrap)
```{r}
confusionMatrix(yhat, predicted) # bootstrap is reference
```

